import pygame
import random
import sys

# Initialisation de Pygame
pygame.init()

# Constantes
LARGEUR = 800
HAUTEUR = 600
NOIR = (0, 0, 0)
CYAN = (0, 255, 255)
BLEU_FONCE = (0, 20, 40)
VERT_MATRIX = (0, 255, 0)
ROUGE_NEON = (255, 0, 100)

# Configuration de la fenêtre
fenetre = pygame.display.set_mode((LARGEUR, HAUTEUR))
pygame.display.set_caption("CYBER-PENDU v2.0")

# Configuration du texte
police = pygame.font.Font(None, 36)
police_titre = pygame.font.Font(None, 50)

class JeuPendu:
    def __init__(self, difficulte='normal'):
        self.mot = ""
        self.lettres_trouvees = set()
        self.lettres_ratees = set()
        self.erreurs = 0
        self.max_erreurs = 7  # Toujours 7 erreurs
        self.en_cours = True
        self.message_systeme = "INITIALISATION DU SYSTÈME..."
        self.difficulte = difficulte
        
    def charger_mot(self):
        with open("mots.txt", "r", encoding="utf-8") as fichier:
            mots = fichier.read().splitlines()
            # En mode difficile, on prend des mots plus longs
            if self.difficulte == 'difficile':
                mots = [mot for mot in mots if len(mot) >= 8]
            # En mode facile, on prend des mots plus courts
            elif self.difficulte == 'facile':
                mots = [mot for mot in mots if len(mot) <= 6]
            # En mode normal, tous les mots sont possibles
        self.mot = random.choice(mots).lower()
        self.message_systeme = "MOT SÉLECTIONNÉ DANS LA BASE DE DONNÉES"
        
    def ajouter_mot(self, nouveau_mot):
        with open("mots.txt", "a", encoding="utf-8") as fichier:
            fichier.write(f"\n{nouveau_mot}")
            
    def afficher_mot_cache(self):
        return " ".join(lettre if lettre in self.lettres_trouvees else "█" for lettre in self.mot)
        
    def verifier_lettre(self, lettre):
        if not self.en_cours:
            return
            
        if lettre in self.mot:
            self.lettres_trouvees.add(lettre)
            # Message système uniquement si le jeu continue
            if not all(lettre in self.lettres_trouvees for lettre in self.mot):
                self.message_systeme = "SÉQUENCE CORRECTE DÉTECTÉE"
            else:
                self.en_cours = False
                self.message_systeme = "DÉCRYPTAGE RÉUSSI"
        else:
            self.lettres_ratees.add(lettre)
            self.erreurs += 1
            # Message système uniquement si le jeu continue
            if self.erreurs < self.max_erreurs:
                self.message_systeme = "ERREUR DE SÉQUENCE DÉTECTÉE"
            else:
                self.en_cours = False
                self.message_systeme = "SYSTÈME CORROMPU"

    def dessiner_pendu(self):
        # Grille de fond cyberpunk (plus subtile)
        for i in range(0, LARGEUR, 40):
            pygame.draw.line(fenetre, (0, 30, 30), (i, 0), (i, HAUTEUR), 1)
        for i in range(0, HAUTEUR, 40):
            pygame.draw.line(fenetre, (0, 30, 30), (0, i), (LARGEUR, i), 1)
            
        # Structure du pendu (potence futuriste)
        pygame.draw.line(fenetre, CYAN, (0, 500), (200, 500), 5)  # Base toujours visible
        
        if self.erreurs > 0:  # 1ère erreur : poteau vertical
            pygame.draw.line(fenetre, CYAN, (100, 500), (100, 100), 5)
        
        if self.erreurs > 1:  # 2ème erreur : poteau horizontal
            pygame.draw.line(fenetre, CYAN, (100, 100), (300, 100), 5)
        
        if self.erreurs > 2:  # 3ème erreur : corde
            pygame.draw.line(fenetre, CYAN, (300, 100), (300, 150), 5)
        
        if self.erreurs > 3:  # 4ème erreur : tête
            pygame.draw.rect(fenetre, CYAN, (275, 150, 50, 40), 2)
            if self.erreurs >= self.max_erreurs:
                # Yeux en X si perdu
                pygame.draw.line(fenetre, ROUGE_NEON, (285, 165), (295, 175), 2)
                pygame.draw.line(fenetre, ROUGE_NEON, (295, 165), (285, 175), 2)
                pygame.draw.line(fenetre, ROUGE_NEON, (305, 165), (315, 175), 2)
                pygame.draw.line(fenetre, ROUGE_NEON, (315, 165), (305, 175), 2)
            else:
                # Yeux normaux
                pygame.draw.rect(fenetre, VERT_MATRIX, (285, 165, 10, 10), 0)
                pygame.draw.rect(fenetre, VERT_MATRIX, (305, 165, 10, 10), 0)
        
        if self.erreurs > 4:  # 5ème erreur : corps et circuits
            pygame.draw.rect(fenetre, CYAN, (275, 190, 50, 60), 2)
            for y in range(200, 240, 10):
                pygame.draw.line(fenetre, VERT_MATRIX, (280, y), (320, y), 1)
        
        if self.erreurs > 5:  # 6ème erreur : bras
            pygame.draw.line(fenetre, CYAN, (275, 200), (250, 230), 2)  # Bras gauche
            pygame.draw.line(fenetre, CYAN, (325, 200), (350, 230), 2)  # Bras droit
        
        if self.erreurs > 6:  # 7ème erreur : jambes et circuits finaux
            pygame.draw.line(fenetre, CYAN, (285, 250), (275, 290), 2)  # Jambe gauche
            pygame.draw.line(fenetre, CYAN, (315, 250), (325, 290), 2)  # Jambe droite
            pygame.draw.line(fenetre, VERT_MATRIX, (275, 270), (280, 270), 1)  # Circuit jambe
            pygame.draw.line(fenetre, VERT_MATRIX, (320, 270), (325, 270), 1)  # Circuit jambe

def menu_principal():
    while True:
        fenetre.fill(BLEU_FONCE)
        # Grille de fond
        for i in range(0, LARGEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (i, 0), (i, HAUTEUR), 1)
        for i in range(0, HAUTEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (0, i), (LARGEUR, i), 1)
            
        titre = police_titre.render("CYBER-PENDU v2.0", True, CYAN)
        texte_jouer = police.render("[ 1 ] LANCER SÉQUENCE", True, VERT_MATRIX)
        texte_ajouter = police.render("[ 2 ] AJOUTER DONNÉES", True, VERT_MATRIX)
        texte_quitter = police.render("[ 3 ] DÉCONNEXION", True, VERT_MATRIX)
        
        fenetre.blit(titre, (LARGEUR//2 - titre.get_width()//2, 100))
        fenetre.blit(texte_jouer, (LARGEUR//2 - 100, HAUTEUR//2))
        fenetre.blit(texte_ajouter, (LARGEUR//2 - 100, HAUTEUR//2 + 50))
        fenetre.blit(texte_quitter, (LARGEUR//2 - 100, HAUTEUR//2 + 100))
        
        # Animation clignotante
        if pygame.time.get_ticks() % 1000 < 500:
            pygame.draw.rect(fenetre, VERT_MATRIX, (LARGEUR//2 - 120, HAUTEUR//2 + pygame.time.get_ticks()//1000 % 3 * 50, 10, 10))
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_1:
                    return "jouer"
                elif event.key == pygame.K_2:
                    return "ajouter"
                elif event.key == pygame.K_3:
                    return "quitter"

def menu_difficulte():
    while True:
        fenetre.fill(BLEU_FONCE)
        # Grille de fond
        for i in range(0, LARGEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (i, 0), (i, HAUTEUR), 1)
        for i in range(0, HAUTEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (0, i), (LARGEUR, i), 1)
            
        titre = police_titre.render("SÉLECTION DIFFICULTÉ", True, CYAN)
        texte_facile = police.render("[ 1 ] FACILE", True, VERT_MATRIX)
        texte_normal = police.render("[ 2 ] NORMAL", True, VERT_MATRIX)
        texte_difficile = police.render("[ 3 ] DIFFICILE", True, ROUGE_NEON)
        
        fenetre.blit(titre, (LARGEUR//2 - titre.get_width()//2, 100))
        fenetre.blit(texte_facile, (LARGEUR//2 - 100, HAUTEUR//2))
        fenetre.blit(texte_normal, (LARGEUR//2 - 100, HAUTEUR//2 + 50))
        fenetre.blit(texte_difficile, (LARGEUR//2 - 100, HAUTEUR//2 + 100))
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_1:
                    return 'facile'
                elif event.key == pygame.K_2:
                    return 'normal'
                elif event.key == pygame.K_3:
                    return 'difficile'

def ajouter_mot_interface():
    nouveau_mot = ""
    en_saisie = True
    
    while en_saisie:
        fenetre.fill(BLEU_FONCE)
        # Grille de fond
        for i in range(0, LARGEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (i, 0), (i, HAUTEUR), 1)
        for i in range(0, HAUTEUR, 20):
            pygame.draw.line(fenetre, (0, 50, 50), (0, i), (LARGEUR, i), 1)
            
        texte_instruction = police.render("ENTREZ NOUVELLE SÉQUENCE:", True, CYAN)
        texte_mot = police.render(f">{nouveau_mot}_", True, VERT_MATRIX)
        
        fenetre.blit(texte_instruction, (50, HAUTEUR//2 - 50))
        fenetre.blit(texte_mot, (50, HAUTEUR//2))
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN and nouveau_mot:
                    return nouveau_mot
                elif event.key == pygame.K_BACKSPACE:
                    nouveau_mot = nouveau_mot[:-1]
                elif event.unicode.isalpha():
                    nouveau_mot += event.unicode.lower()

def main():
    while True:
        choix = menu_principal()
        
        if choix == "jouer":
            difficulte = menu_difficulte()
            jeu = JeuPendu(difficulte)
            jeu.charger_mot()
            
            while True:
                fenetre.fill(BLEU_FONCE)
                # Grille de fond
                for i in range(0, LARGEUR, 20):
                    pygame.draw.line(fenetre, (0, 50, 50), (i, 0), (i, HAUTEUR), 1)
                for i in range(0, HAUTEUR, 20):
                    pygame.draw.line(fenetre, (0, 50, 50), (0, i), (LARGEUR, i), 1)
                    
                jeu.dessiner_pendu()
                
                # Message système (en bas) - seulement si le jeu est en cours
                if jeu.en_cours:
                    texte_systeme = police.render(jeu.message_systeme, True, CYAN)
                    fenetre.blit(texte_systeme, (20, HAUTEUR - 100))
                
                # Affichage du mot caché
                texte_mot = police.render(jeu.afficher_mot_cache(), True, VERT_MATRIX)
                fenetre.blit(texte_mot, (LARGEUR//2 - texte_mot.get_width()//2, 400))
                
                # Affichage des lettres ratées (remis en haut à gauche)
                if jeu.lettres_ratees:
                    texte_ratees = police.render(f"SÉQUENCES ERRONÉES: {', '.join(sorted(jeu.lettres_ratees))}", True, ROUGE_NEON)
                    fenetre.blit(texte_ratees, (20, 20))
                
                # Affichage du nombre d'erreurs
                texte_erreurs = police.render(f"CORRUPTION: {jeu.erreurs}/{jeu.max_erreurs}", True, ROUGE_NEON if jeu.erreurs > 4 else VERT_MATRIX)
                fenetre.blit(texte_erreurs, (LARGEUR - 250, 20))
                
                if not jeu.en_cours:
                    if jeu.erreurs >= jeu.max_erreurs:
                        message = f"ÉCHEC - MOT CLÉ: {jeu.mot}"
                    else:
                        message = "DÉCRYPTAGE RÉUSSI!"
                    texte_fin = police.render(message, True, ROUGE_NEON if jeu.erreurs >= jeu.max_erreurs else VERT_MATRIX)
                    # Message de fin légèrement descendu (de 150 à 140)
                    fenetre.blit(texte_fin, (LARGEUR//2 - texte_fin.get_width()//2, HAUTEUR - 140))
                    
                    # Message de retour au menu (ajusté en conséquence)
                    texte_retour = police.render("APPUYEZ SUR ESPACE POUR RETOUR MENU", True, CYAN)
                    fenetre.blit(texte_retour, (LARGEUR//2 - texte_retour.get_width()//2, HAUTEUR - 70))
                
                pygame.display.flip()
                
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        sys.exit()
                    if event.type == pygame.KEYDOWN:
                        if not jeu.en_cours and event.key == pygame.K_SPACE:
                            break
                        if event.unicode.isalpha():
                            jeu.verifier_lettre(event.unicode.lower())
                
                if not jeu.en_cours and pygame.key.get_pressed()[pygame.K_SPACE]:
                    break
                    
        elif choix == "ajouter":
            nouveau_mot = ajouter_mot_interface()
            jeu = JeuPendu()
            jeu.ajouter_mot(nouveau_mot)
            
        elif choix == "quitter":
            pygame.quit()
            sys.exit()

if __name__ == "__main__":
    main() 